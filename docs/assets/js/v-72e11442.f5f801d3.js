"use strict";(self.webpackChunkaaa=self.webpackChunkaaa||[]).push([[233],{2618:(e,t,a)=>{a.r(t),a.d(t,{data:()=>l});const l={key:"v-72e11442",path:"/guide/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/JAVASCRIPT/%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"闭包的底层理解",slug:"闭包的底层理解",children:[]}],filePathRelative:"guide/面试刷题/JAVASCRIPT/闭包的底层理解.md",git:{}}},2501:(e,t,a)=>{a.r(t),a.d(t,{default:()=>c});var l=a(6252);const n=(0,l._)("h2",{id:"闭包的底层理解",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#闭包的底层理解","aria-hidden":"true"},"#"),(0,l.Uk)(" 闭包的底层理解")],-1),r=(0,l._)("p",null,[(0,l.Uk)("当js引擎预编译时,直接再script标签内编写的代码，会创建GO全局作用域,"),(0,l._)("strong",null,"每调用一次函数,就会产生一次AO函数作用域"),(0,l.Uk)("，作用域链的顶层始终指向当前的作用域,函数结束后销毁,属于后进先出的模式")],-1),s=(0,l._)("p",null,[(0,l._)("img",{src:"D:\\学习\\面试题\\images\\闭包的底层理解.png",alt:""})],-1),i=(0,l._)("p",null,[(0,l.Uk)("如上图，当函数a调用时,与函数b定义时,指向同一个AO函数作用域,函数a调用完成后销毁,"),(0,l._)("strong",null,"由于全局变量res接收函数b为值,所以函数b的作用域并不会销毁,并且依旧能使用 a 的变量")],-1),u={},c=(0,a(3744).Z)(u,[["render",function(e,t){return(0,l.wg)(),(0,l.iD)(l.HY,null,[n,r,s,i],64)}]])},3744:(e,t)=>{t.Z=(e,t)=>{const a=e.__vccOpts||e;for(const[e,l]of t)a[e]=l;return a}}}]);