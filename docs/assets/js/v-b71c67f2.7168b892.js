"use strict";(self.webpackChunkaaa=self.webpackChunkaaa||[]).push([[6554],{5307:(e,a,t)=>{t.r(a),t.d(a,{data:()=>i});const i={key:"v-b71c67f2",path:"/guide/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/JAVASCRIPT/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"事件循环（EventLoop）",slug:"事件循环-eventloop",children:[{level:3,title:"事件循环概念",slug:"事件循环概念",children:[]},{level:3,title:"宏任务与微任务",slug:"宏任务与微任务",children:[]},{level:3,title:"事件执行顺序",slug:"事件执行顺序",children:[]},{level:3,title:"async/await的作用",slug:"async-await的作用",children:[]},{level:3,title:"async/await等待机制",slug:"async-await等待机制",children:[]}]}],filePathRelative:"guide/面试刷题/JAVASCRIPT/事件循环.md",git:{}}},1836:(e,a,t)=>{t.r(a),t.d(a,{default:()=>n});const i=(0,t(6252).uE)('<h2 id="事件循环-eventloop" tabindex="-1"><a class="header-anchor" href="#事件循环-eventloop" aria-hidden="true">#</a> 事件循环（EventLoop）</h2><h3 id="事件循环概念" tabindex="-1"><a class="header-anchor" href="#事件循环概念" aria-hidden="true">#</a> 事件循环概念</h3><p>由于js是单线程应用，如果遇到解析时间长的任务时，可能会阻塞后面的进程，所以js代码也分为同步和异步，执行代码时，js会判断时同步还是异步，如果是同步，就会直接推入主进程，如果是异步，则会进入event table，异步任务在event table注册事件，当满足触发条件时（触发条件可能是ajax回调或延时）被推入event queue，<strong>同步任务进入主进程后就一直执行，直到主进程空闲后才会去event queue中查看是否有可执行的异步任务，有就推入主进程</strong>，不断的重复这个过程就是事件循环(概念见下图)</p><p><img src="/boke/面试刷题/事件循环1.png" alt=""></p><h3 id="宏任务与微任务" tabindex="-1"><a class="header-anchor" href="#宏任务与微任务" aria-hidden="true">#</a> 宏任务与微任务</h3><p>异步任务有分为宏任务与微任务 <strong>new promise属于同步任务</strong></p><ul><li><p>常见的宏任务</p><p>setTimeout setInterval requestAnimationFrame</p></li><li><p>常见的微任务</p><p>Promise.then()</p></li></ul><h3 id="事件执行顺序" tabindex="-1"><a class="header-anchor" href="#事件执行顺序" aria-hidden="true">#</a> 事件执行顺序</h3><p>宏任务==》同步任务==》微任务</p><p>当第一次执行事件循环时,会将script脚本当做一个宏任务执行,先将宏任务中的同步任务执行，遇到宏任务推送到宏任务队列（先进先出），遇到微任务推送到微任务队列（先进先出），当目前同步任务执行完毕后执行微任务队列中的微任务，当全部微任务执行完毕后，则执行宏任务队列中的下一个宏任务，如此循环直到结束（见下图）</p><p><img src="/boke/面试刷题/事件循环2.png" alt=""></p><h3 id="async-await的作用" tabindex="-1"><a class="header-anchor" href="#async-await的作用" aria-hidden="true">#</a> async/await的作用</h3><p>async会返回一个promise对象,如果你再函数中return一个普通变量,那么async会将这个普通变量通过Promist.resolve()封装后返回,如果return一个promise，那么将以返回的promise为准，await在等待结果值的返回,<strong>await下面的代码相当与在.then()中执行</strong></p><h3 id="async-await等待机制" tabindex="-1"><a class="header-anchor" href="#async-await等待机制" aria-hidden="true">#</a> async/await等待机制</h3><p>如果 await 后面跟的不是一个 Promise，那 await 后面表达式的运算结果就是它等到的东西；如果 await 后面跟的是一个 Promise 对象，await 它会“阻塞”后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值作为 await 表达式的运算结果。但是此“阻塞”非彼“阻塞”这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成“阻塞”，它内部所有的“阻塞”都被封装在一个 Promise 对象中异步执行。（这里的阻塞理解成异步等待更合理）</p><p><img src="/boke/面试刷题/事件循环3.png" alt=""></p>',16),r={},n=(0,t(3744).Z)(r,[["render",function(e,a){return i}]])},3744:(e,a)=>{a.Z=(e,a)=>{const t=e.__vccOpts||e;for(const[e,i]of a)t[e]=i;return t}}}]);